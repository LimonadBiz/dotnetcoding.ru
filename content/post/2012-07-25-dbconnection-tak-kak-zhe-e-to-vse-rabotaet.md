---
title: 'DbConnection &#8212; Так как же это все работает?'
author: dotnetcoding
type: post
date: 2012-07-24T21:10:31+00:00
url: /coding/dbconnection-tak-kak-zhe-e-to-vse-rabotaet.html
description:
  - 'Посмотрим на все с такой точки зрения: под классом DbConnection. имеется класс брокера, управляющий пулом открытых подключений. '
robotsmeta:
  - index,follow
categories:
  - .NET Программирование

---
Посмотрим на все с такой точки зрения: под классом DbConnection. имеется класс брокера, управляющий пулом открытых подключений. Он отвечает за увеличение или уменьшение реального количества открытых подключений в зависимости от потребностей приложения. <!--more-->Для класса брокера каждое запрошенное подключение уникально идентифицируется соответствующей строкой подключения. Поэтому когда любое приложение на одной и той же машине запрашивает открытое подключение, оно вначале просматривает внутренний кэш пула подключений, и если в нем есть доступное подключение, то используется оно. А при отсутствии доступного подключения создается новое (но не свыше указанного предела), которое и передается приложению.

Аналогично, когда приложение завершает использование подключения и вызывает метод Dispose или Close объекта подключения, класс брокера отмечает подключение как не используемое или не выделенное, но сохраняет его в готовности для следующего пользователя, которому оно может понадобиться.
  
Конкретнав реализация можег быть не такой простой, но здесь описано самое главное. И важно понять, что поток, вызвавший метод Open, может даже не различать подключения из пула и обособленные подключения, за исключением существенной разницы в производительности.

Результаты выполнения листингов 4.10 и 4.11 можно также проверить с помощью Монитора производительности- Чтобы проконтролировать, как и в каком количестве устанавливаются реальные подключения к базе данных, можно отслеживать счегчик SQLServer:Genera 1 Statistics\Uscr Connections. Если вы хотите испытать настоящий шок, можно создать новый объект SqlConnection, закомментировать закрытие подключения, и открывать подключения {без закрытия) для создаваемых в быстрой последовательности объектов SqlConnect юг,, чтобы увидеть использование подключений приложением. Можно сделать еше хуже, выполняя открытия не в цикле, чтобы создаваемые объекты подключений не убирались в качестве мусора по завершении цикла — такая ситуация еще больше похожа на работу приложения без пула подключений при высокой загрузке. Следовательно, крайне важно закрывать подключения как можно раньше, а открывать как можно позже — иначе производительность приложения очень быс гро упадет до уровня плинтуса. К сожалению, такая ситуация возникает только в специальных интенсивных тестах, либо во время промышленной эксплуатации, поэтому важно проектировать слой доступа к данным, учитывая этот нюанс.