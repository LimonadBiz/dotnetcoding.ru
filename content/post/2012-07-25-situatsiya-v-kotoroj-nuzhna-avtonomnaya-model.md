---
title: Ситуация, в которой нужна автономная модель
author: dotnetcoding
type: post
date: 2012-07-25T10:38:46+00:00
url: /coding/situatsiya-v-kotoroj-nuzhna-avtonomnaya-model.html
robotsmeta:
  - index,follow
categories:
  - .NET Программирование

---
Всем нравятся сказки перед сном — вот и я начну с такой сказки.

Джон — очень занятый менеджер, и ему обычно приходится много работать на компьютере. У него мощный компьютер с большим .жестким диском, и ему приходится работать с множеством таблиц Excel и документов Word. <!--more-->Часто Джон присутствует на совещаниях в конференц-зале. В первый раз, когда Джон пришел на такое совещание, он подумал, что ему нужно оставаться &#171;подключенным&#187; к своему компьютеру, и он часто бегал туда-сюда за каждым документом, который мог понадобиться на совещании. Часто бывало так, что Джон начинал обсуждение какого-то вопроса, а затем ему приходилось прерываться и бежать к компьютеру за необходимыми документами. Конечно, можно было работать и так, но Джон и его коллега быстро поняли, что это не самое эффективное использование рабочего времени. И дело не только в том. что Джон бегал слишком часто, ведь всем остальным приходилось ждать, когда он принесет нужный. Это было просто разбазаривание ценных ресурсов.

Поэтому Джон купил себе ноутбук. И хотя у ноутбука не такой большой жесткий диск, не такой мощный процессор, даже клавиатура и дисплей меньшего размера. он все же позволяет захватить небольшой набор таблиц Excel и документов Word, которые могут понадобиться на совещании, а остальное все так же находится на настольном компьютере. Ноутбук — не совсем настольный компьютер, но все-таки Джону теперь не нужно постоянно бегать к компьютеру. Он может оперативно вносить изменения в документы Word и таблицы Excel, а после совещания переписать эти документы на компьютер.

И все счастливы: Джону не нужно постоянно отлучаться, а его коллегам не нужно его ждать.

Этот пример очень похож на приложение уровня предприятия. Джону приходилось бегать в конферецц-зал, находящийся на расстоянии нескольких метров, но в Internet клиенты обычно разбросаны по всему земному шару и то и дело пытаются подключиться к базе данных. Когда при работе в многопользовательском режиме один клиент работает с данными и удерживает подключение открытым, другим клиентам часто приходится открывать новые физические подключения к базе данных, чтобы выполнять свою работу. При этом самая большая нагрузка падает на центральную базу данных, которой приходится управляться с большим количеством физических подключений, чем это нужно в данный момент. Хотя большую часть времени источник данных простаивает, ожидая от пользователя обновления данных или запроса на другие данные.

Такую ситуацию легко разрешить так, как это сделал Джон: все необходимые данные можно сохранить в отдельном объекте (ноутбук или DataSet). Этот объект, конечно, не сравнить с самой базой данных; возможно, он не может вместить столько данных, сколько их в базе данных, и, возможно, у него нет таких возможностей обработки запросов, как у базы данных, но в автономных случаях он работает великолепно.

Чтобы такой объект мог выполнять полезную работу в автономных ситуациях, он должен обладать следующими желательными характеристиками:

• Он должен быть сериализуемым. Класс является сериализуемым, если он может сохранить состояние памяти (или данных) в последовательном потоке байтов, который позже можно прочитать или послать на обработку кому-то другому. Работая в автономной ситуации, вам придется посылать подмножество данных в сеть, на другую машину, или другому процессу. Поэтому нужна сериализация класса.
  
* Он должен работать с XML. Сериализация класса — это хорошо, но она, возможно, будет выполнена в двоичную форму. Однако двоичная форма не понятна для людей. Именно по этой причине XML является универсальным языком компьютерного мира: он поиятен и людям, и компьютерам. Он, возможно. и не идеален в некоторых ситуациях {например, в беспроводных сетях), где некоторые дескрипторы могут сделать его непригодным для работы с подключениями с низкой пропускной способностью. Однако в силу текстовой природы и существования текстовых анализаторов практически для любой платформы такой объект, хранящий подмножество данных, скорее всего, будет хорошо работать с XML.

* Он должен поддерживать историю изменений. Запрос данных — это лишь полдела, обычно потом нужно заносить изменения назад в базу данных, учитывая еще и все нюансы параллельной работы. Было бы хорошо, чтобы объект хранил историю изменений, выполненных в нем с момента выборки исходных данных. Это позволило бы программисту легче разрешать проблемы наподобие параллельного доступа к данным.

было продемонстрировано заполнение объекта ArrayList экземплярами DbDat aRecord. Для одного и того же объема данных ArrayList гораздо проще, чем DataSet, но этот объект не удовлетворяет двум только что сформулированным пожеланиям: Однако в некоторых ситуациях он может оказаться лучшим. Например, если не нужны возможности работы с ХМL, или система выполняет только чтение данных (например, часть web-сайта управления контентом, которая отвечает за представление информации, либо дополнительный запрос к базе данных перед обновлением, чтобы устранить проблемы параллелизма). то в качестве представления объекта данных можно выбрать ArrayList.

Но если ArrayList не удовлетворяет требованиям вгшхей архитектуры, вы можете создать собственное представление бизнес-объекта, которое удовлетворяет всем трем условиям, а. может, и другим важным для вас условиям. Либо можно воспользоваться классом DataSet, входящим в состав ADO.NET, который удовлетворяет всем трем условиям и кое-каким другим.

Вот пример: при работе с автономными данными нужно, в частности, позаботиться о ведении модифицируемой и обновляемой копии данных. В DataSet имеются встроенные механизмы — такие как возможность извлечения изменений или слияние с другим DataSet — которые позволяют написать код, отбрасывающий устаревшие данные. Нечто аналогичное можно реализовать и в других объектах, например, в ArrayList, но там придется начинать с пуля и затратить больше усилий, чем при работе с DataSet.