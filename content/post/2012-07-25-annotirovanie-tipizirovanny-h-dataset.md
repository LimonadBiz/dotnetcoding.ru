---
title: Аннотирование типизированных DataSet
author: dotnetcoding
type: post
date: 2012-07-25T11:00:05+00:00
url: /coding/annotirovanie-tipizirovanny-h-dataset.html
robotsmeta:
  - index,follow
categories:
  - .NET Программирование

---
некоторых наиболее популярных возможностей XSD, уже было рассмотрено аннотирование схем. Там было сказано, что аннотации могут иметь две формы: элемент <documentation> для просмотра человеком и элемент <appmfo>. Здесь мы рассмотрим (и научимся применять) еще одни вариант аннотации, в котором не используется XSD-элемент <annotation>
  
<!--more-->


  
Как было показано в предыдущем примере, при создании строго типизированного DataSet с помощью стандартной техники имена свойств, методов, отношений и ограничений класса DataSet создаются за вас автоматически. Если предполагается использовать много типизированных DataSet, либо вы планируете подготовить их для нескольких других программистов или команд, то, к счастью, имеется возможность тонкого управления соглашениями по именованию и автоматизированными возможностями генератора кода для типизированных классов DataSet.

Это выполняется с помощью специальных атрибутов из двух пространств имен XML, предоставляемых Microsoft: первое пространство — codegen (определенное записью xmlns : codegen=&#187;urn : schemas-raicrosoft-com: xra.l-rasprop &#171;), а второе— пространство имен msdata (определенное записью xralns :msdata= &#171;urn : schemas-mi crosoft-com :xral-msdata&#187;).

**codegen**

Пространство имен codegen содержит множество атрибутов, которые непосредственно влияют на генерацию кода класса DataSet. Атрибуты codegen можно применять к различным элементам XSD-файла, обеспечивая таким образом подробные инструкции компилятору (XSD. ехе или VS.NET), как в точности генерировать новый DataSet. В конце этого раздела приведен пример DataSet, аннотированного в Visual Studto .NET с помощью этих новых атрибутов.

Вся эта функциональность допускает возможность последующего управления из программы с помощью изменения свойств. Но если функции и управление встроены в схему и типизированный DataSet в виде, понятном человеку, то сомнений о том, как создатель класса предполагает его использовать, не будет.

**typedName**

Атрибут typedName указывает имя объекта, которое появится в новом DataSet. Этот атрибут применим к DataTables, DataRows, свойствам и событиям DataSet.

**typedPlural**

Атрибут typedPlural указывает имя объекта, когда необходимо множество таких объектов — как в объекте DataRowCollection или DataTableCollection.

**typedParent**

Атрибут typedParent указывает имя объекта при его упоминании в родительском отношении. Типизированные DataSet автоматически генерируют функции доступа для выборки родительских и дочерних объектов. Например, в предыдущем примере функция GetBookReviewsRows () была дочерней функцией доступа.

**typedChildren
  
** 
  
Атрибут typedChildren указывает имя объекта при его упоминании в дочернем отношении. Как было сказано выше, типизированные DataSet генерируют функции доступа для выборки родительских и дочерних объектов, обычно с непонятными и запутанными именами. Предоставление атрибутов typedChildren и typedParent обычно существенно облегчает понимание пользователем вашего типизированного DataSet.
  
**
  
nullValue**

Атрибут nullValue очень полезен. Он позволяет определять действие, которое будет выполнено в DataSet, когда встретится значение DBNull. Ниже приведен список допустимых значений для атрибута nullValue:

• &#187; замена &#187; — вместо описания поведения можно просто указать, какое значение должен запоминать DataSet вместо DBNull.

• ”_throw&#187; — возбуждает исключение при каждом появлении DBNull в соответствующем элементе в DataSet.

• &#171;__null&#187; — возвращает густое значение (или возбуждает исключение в случае примитивного типа).

• &#171;_empty&#187; — возвращает объект, созданный в густом конструкторе. В случае строк возвращается String. Empty. Для остальных примитивных типов возбуждается исключение.

msdata

Пространство имен msdata — еще одно пространство имен, используемое Microsoft для управления поведением DataSet. Оно обычно имеет дело с определением, именованием и управлением ключами и ограничениями. Ниже описаны определяемые этим пространством атрибуты.
  
**ConstraintName
  
** 
  
Это имя ограничения в том виде, в котором оно входит в DataSet. Оно может применяться к ограничению любого вида, определенному в XSD, например, к ограничению <кеу> или <unique>.

**ConstraintOnly**

По умолчанию генератор кода создает отношение при каждом обнаружении ограничения по внешнему ключу. Флаг Const raintOnl у позволяет перекрыть это поведение и не создавать автоматически отношение. Синтаксис:

<element msdata:ConstraintOnly="true" />

**UpdateRule**

Этот атрибут управляет поведением соответствующих строк родителей и потомков при изменении строк. Если он отсутствует, то по умолчанию принимается значение Cascade. Но он может принимать значения None, SetDefault или SetNuU. в соответствии с параметрами, приведенными выше в данной главе:

• Cascade — каскадирует изменение по всем соответствующим строкам.

• None — для соответствующих строк не выполняется никакое действие.

• SetDefault — всем строкам, на которые действует изменение, присваиваются их стандартные значения, указанные в соответствующих свойствах DefaultValue.

• SetNull — во все соответствующие строки в качестве результата изменения заносится DBNull.

**DeleteRule
  
** 
  
Возможные значения для этого атрибута действуют идентично атрибуту UpdateRule, но они применяются тогда, когда выполняется удаление.

**Relationship**

Как и в случае всех нормальных правил, для приведенного выше утверждения, что эти аннотации не входвт в элемент <annotation>, есть исключение. Элемент <Relationship> может входить в элемент аннотации <appmfo>. Пожеланию его можно использовать для определения родительского отношения как способ, альтернативный использованию синтаксиса key/keyref. Это вопрос личного предпочтения, и многие приверженцы чистого XSD предпочитают использовать синтаксис key/keyref. В любом случае синтаксис таков:

<xs:annotation>

<xs:appinfo>

<msdata:Relationship name="KeyBookIDRef" rrsdata :t>arent=”Books&#187; msdata:child=&#187;3ookReviews&#187; msdata:parentkey=&#187;BookID&#187; msdata:chUdkey=&#8217;,BookID&#187; />

</xs:appinfo>

</xs:annotation>