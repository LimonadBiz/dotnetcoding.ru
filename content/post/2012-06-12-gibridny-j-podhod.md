---
title: Гибридный подход
author: dotnetcoding
type: post
date: 2012-06-12T06:29:38+00:00
url: /coding/gibridny-j-podhod.html
robotsmeta:
  - index,follow
categories:
  - .NET Программирование

---
**Гибридный подход: немного написанного кода и немного перетаскивания**<!--more-->

В предыдущем примере было показано, как можно легко создать управляемое данными приложение на основе Windows-формы, просто перетаскивая различные компоненты в окно формы. Здесь важно понять, что код был сгенерирован автоматически по принципу &#171;один размер для всех&#187;. Этот большой объем крайне обобщенного кода, написанного таким образом, логически корректно работает для большинства приложений: однако этот код может быть не самым эффективным. Конечно, он работает в большинстве ситуаций, но может встретиться одна нестандартная ситуация, когда код окажется бессилен. Вы можете представить промышленное приложение с 500 таблицами? А теперь представьте себе перетаскивание мышью 500 таблиц в архитектуре визуального конструирования. Это просто невозможно сопровождать. А. кроме того, этот код невозможно приспособить к любой ситуации, с которой вы можете встретиться.

Но этот подход все же занимает свое место в конструировании приложений. В некоторых ситуациях создание полнофункционального прилолссния с помощью только перетаскивания — это совсем не то, что нужно, но автоматически сгенерированный код можно использовать, задействуя различные сгенерированные объекты и самостоятельно написав код.
  
Рассмотрим пример, демонстрирующий такой гибридный подход. Это приложение можно загрузить с web-сайта издательства под именем ConsoleApp, а можно создать его самостоятельно, выполнив «следующие шаги:

1. Вначале создайте новое консольное приложение и назовите его ConsoleApp.

2. Выполните шаги 2-7 создания Windows-приложения, чтобы добавить новый источник данных. Поскольку код, создаваемый в этом упражнении в соответствии с гибридным подходом (сочетание перетаскивания мышью и написание кода), будет входить в консольное приложение, таблицу Demo не имеет смысла указывать в элементе DataGndView или каком-то другом.

3. В консольном приложении напишите код. Этот код понадобится для заполнения информацией таблицы Demo в объекте testDS . Demo, а затем выведите значение из столбца DemoValue первой строки.

**Код для заполнения информацией источника данных и вывода “Heiio World&#187; на C#**

> TestDataSet testDS &#8212; new TestDataSet () ;
  
> TestDataSetTableAdapters.DemoTableAdapter tableAdapter &#8212; new TestDataSetTabI eAdapters.BenoTableAdapler();
  
> tableAdapter.Fill(testDS.Demo);
  
> TestDataSet.DemoRow demoRow =
> 
> (TestDataSet.DenoRow)testDS.Demo.Rows[01; Console.WriteLine(demoRow.DemoValue); 

**Код для заполнения информацией источника данных и вывода &#171;Heiio Worid” на Visual 8asic NET**

> Dim testDS As TestDataSet = N&#8217;ew TestDataSet ()
> 
> Dim tableAdapter As TestDataSetTabieAdapters.JemoTableAdapter =
> 
> New TestDataSetTabieAdapters . DemoTableAdapter () tableAaapter . Fi 1 T (tesr.DS. Demo)
> 
> Dim demoRow As TestDataSet.DenoRow &#8212;
> 
> CType(testDS.Demo.Rows(3), TestDataSet.DemoRow)
> 
> Console.WriteLine(derroRow.DemoValue) 

Как видите, совсем не трудно написать несколько строк кода, чтобы задействовать большой объем автоматически сгенерированного кода.На самом деле нужно выполнить лишь четыре шага:
  
1. Вначале нужно создать экземпляр TestDataSet:
  
c#

> TestDataSet testDS = row TestDataSet() ;

VB.NET

> Dim testDS As TestDataSet = New TestDataSet()

2. Вторым шагом нужно создать новый экземпляр автоматически сгенерированного класса DemoTableAdapter. Учтите, что это сгенерированный класс, т.е. что это адаптер таблицы для вашей конкретной ситуации и указанной вами таблицы. Как будет показано в главе 9. для того чтобы это было возможно. среда написала за вас большой объем кода. Другими словами, этот код ие принадлежит .NET Framework, а создан из существующих классов •NET Framework, чтобы предоставить класс DemoTabieAdapter, нужный для вашей конкретной цели и ситуации:

C#

> TestDacsSetTableAdapters.DemoTabieAdapter tableAdapter -new TestDataSctTabieAdapters.DemoTableAaapter(); 

VB.NET

> Dim tableAdapter As TestDataSeLTableAdapters.DemoTabieAdapter &#8212; _
> 
> New TestDataSelTabieAddpierb.OemoTabloAdapter() 

3. В третьем шаге нужно воспользоваться объектом DemoTabieAdapter для заполнения таблицы testDS . Den-.o. Как будет показано в главах 6 и 7, эта операция заполнения на самом деле выполняется объектом DataAdapter, но в нашем случае среда скрывает от нас вес эти сложности. Понятно, что если нужен более глубокий контроль (например, работа с иерархическими данными или другие подобные ситуации), то этот подход уже не сработает. В главе 10 описан пример использования иерархических данных, где вряд ли получится правильно применить этот подход для работы с относительно более сложной структурой данных:

C#

> tableAdapter.Fill(testDS.Demo);

VB.NET

> tableAdapter.Fill(testDS.Demo)

4. И последним шагом нужно выполнить запрос значения столбца DemoValue первой строки заполненного объекта. Это очень похоже на запрос к DataSet, потому что TestDataSet — это просто класс, унаследованный от DataSet. Он также называется строго типизованным DataSet, но эта тема будет рассматриваться в главе 6:

C#

> TestDataSet.DemoRow aemoRow =
> 
> (TestDataSet.DemoRow)LesIDS.Demo.Rows &#8216;0];
> 
> Console. Write Line (demoRo»J. DcmoVa I ue);

VB.NET

> Dim denoRow As TestDataSet.DemoRow =
> 
> CType(testDS.Demo.Rows(2), TestDataSet.DeroRow)
> 
> Console.Wrn tel.ino (aerroRow.DerncValue)

Этот код дает несколько большую гибкость, чем чистый подход с перетаскиванием мышью. Но все-таки вы не сможете понять, что происходит за кулисами, не забравшись в ADO.NET еще глубже.

_Например: где в приведенном выше коде находится SQL3anpoc?_
  
Как будет показано, SQL-запрос упрятан глубоко внутри кода, автоматически сгенерированного для TestDataSet. Но отложим этот вопрос.