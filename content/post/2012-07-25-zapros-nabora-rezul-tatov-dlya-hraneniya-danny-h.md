---
title: Запрос набора результатов для хранения данных
author: dotnetcoding
type: post
date: 2012-07-25T09:47:56+00:00
url: /coding/zapros-nabora-rezul-tatov-dlya-hraneniya-danny-h.html
robotsmeta:
  - index,follow
categories:
  - .NET Программирование

---
В предыдущем разделе было показано, как компонент чтения данных позволяет перебирать коллекцию строк в наборе результатов. А если понадобится использовать эти данные для привязки или сложной обработки? Если работа над данными требует большого времени, то в подключенном режиме придется держать подключение открытым, а ото снизит производительность пула подключений. <!--more-->Следовательно, при необходимости выполнения существенного объема обработки после чтения каждой строки лучше прочитать все нужные строки и закрыть исходное подключение. А имея данные, можно приступить к их обработке.

Класс SqlDataReader содержит метод GetEnumerator. Этот метод можно применять в конструкции foreach. где он последовательно возвращает объекты, хранящиеся в коллекции, к которой принадлежит нумератор. В случае SqlDataReader нумератор возвращает по одному объекту DbDa-aRecord.

Рассмотрим сказанное выше на примере, который можно загрузить с web-сайта издательства под именем Example 5.3, а можно просто выполнить следующие шаги:

1. Создайте оконное приложение (Windows Fbrms).

2. На форму Forml приложения поместите компонент DataGndView и назовите его myOataGri d. Оформите его но своему вкусу,

3. Поместите на форму кнопку и назовите ее btnPopulate. Текст на кнопке замените на Populate Arraylist (Заполнение динамического массива).

4. По желанию добавьте другие &#8216;Украшения&#8217; — например, измените размер формы, установите стиль окна FixeaSingle, деактивируйте кнопку Maximize, аккуратно расположите управляющие элементы и т.д. В режиме конструирования форма должна выглядеть примерно так.

5. Дважды щелкните на кнопке otnPopulate, чтобы открыть код — курсор будет помещен в функции, которая будет вызываться во время работы формы при щелчке на кнопке.

Теперь посмотрим, что делает код из листингов. Он создает команду и выбирает компонент чтения данных — так же, как консольное приложение из примера. Но на этот раз вместо выборки данных с помощью функций Get происходит перебор различных DbDataRecord и помещение их в объект Array!,] st с именем dbRecordsHolder. Этот объект существует в виде приватной переменной нашего класса и создан в конструкторе, как показано в загружаемом с сайта коде. Поскольку объект ArrayList непосредственно привязывается но данным, его можно просто связать с компонентом myDataGnd, кая? это сделано в шаге 7. Но учтите, что в приложениях ASP.NET можно выполнить привязку компонента чтения данных и напрямую.

Интересно, что если теперь щелкнуть на кнопке Populate ArrayList, то объет ArrayList заполняется, а подключение закрывается, т.к. для объекта подключения вызывается метод Dispose. Так что в этот момент все данные находятся в объекте ArrayList, полностью отключенном от базы данных. Самым большим преимуществом этого способа явлветсн то. что SqTConriection не остается открытым, когда приложение занято привязкой по данным с пользовательским интерфейсом.

Практическим следствием того, что SqlConnection не держится отрытым при привязке но данным, является минимально возможное время открытия подключения. Это приводит к существенному повышению производительности пула подключений.

Скомпилируйте и запустите приложение. Щелкните сначала на кнопке Populate ArrayList, а затем на кнопке DataBind. 

Обратите также внимание, что теперь при попытке изменения данных с помощью DacaGndView этот элемент знает, что объект не является редактируемым, и выводит данные в режиме только для чтения.

Мы кратко рассмотрели автономный режим хранения данных. Боле подробно автономный доступ if данным будет рассмотрен, а пока мы вернемся к обсуждению подключенного режима выборки данных.

Примеры, приведенные до сих пор в данной главе, выполняли запросы к таблице TestDemo из двух столбцов и трех строк. Но совсем не редкость таблицы, содержащие десятки тысяч строк. В качестве эксперимента можно измени гыекст команды так, чтобы она указывала на большую таблицу, и еще раз выполнить код из примера. Вы заметите, что при выполнении команды пользовательскому интерфейсу будет трудно даже выполнять свою перерисовку, т.к. его основной ноток занят выполнением команды из SqiCommand.

Возвратимся к этому упражнению и обсуждению выборки данных в подключенном режиме, и поставим такие вопросы: &#171;А что, если понадобится выбрать очень много записей (скажем, 500 ООО)? Подвесит ли выполнение такой команды пользовательский интерфейс на несколько секунд?’’ Или: &#171;Что, если нужно напечатать отчет, который генерируется 15 минут? Можно ли выполнить команду, которая выбирает данные для этого отчета и извещает пользователя, когда станут доступны результаты?&#187; Другими словам, хотелось бы выполнить команду асинхронно: запустить ее на выполнение и освободить основной поток для других целей, таких как перерисовка или реагирование на ввод пользователем с клавиатуры.

Прежде чем приступить к рассмотрению асинхронного выполнения SqiCommana. давайте выясним, что я понимаю под асинхронным вьшолиением команды.

Представьте себе, что сегодня я ожидаю получения срочного пакета. Один из вариантов — сидеть на крылечке и ждать курьера. Другой вариант — пойти работать и попросить соседского подростка покараулить курьера и вызвать меня, когда он прибудет.

В первом случае я буду сидеть на крыльце и нудно ждать, когда появится курьер с моим пакетом. Это вполне возможно, по это жуткая растрата рабочего времени. И эквивалент синхронного выполнена задачи- Я все время ожидаю курьера и ничего в это время не делаю.

Второй вариант — я не ожидаю результатов сам. Вместо этого кто-то выполняет эту работу за меия, а потом известит меня (обратный вызов), когда пакет прибудет. Все это время я могу заниматься другими важными задачами. Это эквивалент асинхронного выполнения задачи.

Теперь применим эту парадигму к долгоиграющей Sql Corrmand.