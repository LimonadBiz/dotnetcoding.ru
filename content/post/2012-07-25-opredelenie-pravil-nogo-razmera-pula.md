---
title: Определение правильного размера пула
author: dotnetcoding
type: post
date: 2012-07-25T09:35:51+00:00
url: /coding/opredelenie-pravil-nogo-razmera-pula.html
robotsmeta:
  - index,follow
categories:
  - .NET Программирование

---
Правильный размер пула зависит от вида приложения, с которым он должен работать. В большинстве случаев лучше просто оставить стандартные значения параметров. Однако для принятия осмысленного выбора размера пула крайне важно понимать, что пулы ведутся на отдельных клиентских машинах, на которых выполняется ADO.NET, а не на сервере баз данных.<!--more-->

На ASP.NET-сайте нет никакого смысла отключать пул подключений. Но при работе большого количества узлов в архитектуре с балансировкой сетевой нагрузки, когда все узлы подключаться к одному и тому же серверу баз данных, необходимо понимать, что размер пула для этого сервера умножается на количество узлов или серверов, обслуживающих web-сайт.

Аналогично, при наличии нескольких подключенных удаленных серверов приложений или просто web-службы с ростом количества серверов приложений прямо пропорционально увеличивается количество активных подключений в пуле.
  
Приложение в ковбойском стиле — это приложение, требующее подключения к базе данных непосредственно с компьютера пользователя. Между ними нет ни сервера приложения, ни web-службы, ни web-сайта. В этом случае каждый клиент поддерживает свой пул подключений. Это означает, что при наличии 1000 клиентов базе данных придется справляться с 1000-кратным увеличением размера пуда подключений. А если в архитектуре имеются еще и утечки открытых подключений, то эта ситуация быстро ухудшается. Именно по этой причине большинство поставщиков данных, поддерживающие пул подключений, дают программисту возможности тонкого управления параметрами, определяющими поведение этого пула.

Хотелось бы для каждого клиента иметь один глобальный экземпляр DbConnection и держать его открытым все время жизни приложения. При этом возникает очевидная проблема: невозможность выполнения (по крайней мере, надежного выполнения) для одного и того же подключения нескольких команд одновременно. Можно воспользоваться технологией MARS (Multiple Active Resultsets — множественные активные наборы результатов), но это совсем не то же самое, что параллельное выполнение команд по одному подключению. 

Предположим, что вы каким-то образом, реализовав блокировки или семафоры, создали решение с параллельным выполнением нескольких команд на одном из совместно используемых объектов подключения: тогда простое приложение на основе Windows-формы сможет держать подключение постоянно открытым, и пул подключений можно смело отключить и обходиться без него.

В такой особой ситуации отказ от пула подключений и работа с постоянно открытым объектом подключения (т.е. с постоянно открытым сетевым или физическим подключением) не сильно повлияет на производительность — но тогда вы станете заложником этой архитектуры, и при возрастании потребностей приложения уже не сможете правильно подключаться к базе данных на сервере приложения с помощью слоя данных и пула подключений. Я уже не говорю о том. что если обычное Windows-приложение завершится аварийно, не закрыв перед этим подключение, то остается надежда лишь на сборщик мусора. К сожалению, уборка мусора выполняется в случаях нехватки памяти, а сам объект SqlConnection занимает очень небольшой объем памяти. Поэтому сборщик мусора спокойно проигнорирует тот факт, что открытый объект SqiConneclior. занимает существенный объем системных ресурсов.

Вот об этом должны позаботиться вы, как архитектор или разработчик приложения. Либо просто не изобретайте колесо и положитесь на пул подключений, который позаботится обо всем за вас. Конечно, если слишком много отдельных клиентских пулов слишком загружают сервер, необходимо должным образом настроить параметры конкретного пула подключений.